# Potential Vulnerability Report

Affected products: SEV-SNP capable processors

Tested on an AMD EPYC 7713, microcode: 0xa001173, SEV firmware 1.51 (build 3)

Short description: The host can suppress delivery of #DB exceptions generated by single stepping in an SEV-SNP guest.

## Bug

### Intercepts

During execution of a VM, the host can intercept certain events happening in the guest. Among these events are mostly reads and writes to control registers (e.g. `CR[0-15]`, `IDTR`, `GDTR`) and execution of certain instructions (e.g. `HLT`, `CPUID`, `INVLPG`). One of these events, that will be important later, is the nested page fault which happens when the guest attempts to access guest physical memory that isn't mapped in the guest page tables. This event gives to host a chance to correct the nested page tables before resuming execution of the guest.

### EXITINTINFO

When an intercept is triggered while delivering an exception or interrupt, information about it is saved in the `EXITINTINFO` field. This allows the host to reinject the exception/interrupt after handling of the intercepts to ensure proper execution in the guest.

Note that for most exceptions reinjection isn't strictly needed. For example, if a #UD exception is generated inside the guest and the interrupt descriptor table is not mapped in the nested page tables, this will cause a nested page fault. Once the host corrects this, execution will continue at the same instruction, once again causing #UD exception, which can now be delivered because the host mapped in the interrupt descriptor table. The #UD exception will happen regardless of whether the host chooses to reinject.

This property is important to SEV-SNP because the host is not trusted in the threat model for SEV-SNP. The guest shouldn't rely on the host to reinject exceptions. In fact, if Restricted Injection is enabled for the guest, it's impossible for the host to reinject exceptions.

### Where it all goes wrong

Not all exceptions will repeat after an intercept: #DB exceptions caused by single stepping are deliviered **after** execution of the instruction. This means that the host can suppress delivery of these exceptions by causing an intercept at the same time. Fortunately for the attacker, this is easy to achieve by unmapping the interrupt descriptor table from the nested page tables thus causing a nested page fault.

I'm not sure if there are other exceptions that can be suppressed.

## Proof of Concept

### How to run it

Attached to this report is a VMM that boots an SEV-SNP guest with a custom kernel. The VMM and kernel are a stripped down version of a project of mine. A modified Linux kernel is required to run on the host: https://github.com/Freax13/linux/tree/for-amd.

The Proof of Concept can be run like this:
```bash
cd host
cargo run -p vmm
```

### Explanation

This code jumps back and forth between two instructions:

```assembly
2:
    nop
    jmp 2b
```

When the TF flag is set in the FLAGS registers exceptions should be generated with the instruction pointer alternating between the two instructions.

The guest kernel defines an exception handler that simply logs the instruction pointer reported in the interrupt stack frame. In theory, the logs should look like this:
```
...
[INFO  kernel/src/exception.rs:50] nop
[INFO  kernel/src/exception.rs:56] jmp
[INFO  kernel/src/exception.rs:50] nop
[INFO  kernel/src/exception.rs:56] jmp
[INFO  kernel/src/exception.rs:50] nop
[INFO  kernel/src/exception.rs:56] jmp
[INFO  kernel/src/exception.rs:50] nop
[INFO  kernel/src/exception.rs:56] jmp
[INFO  kernel/src/exception.rs:50] nop
[INFO  kernel/src/exception.rs:56] jmp
[INFO  kernel/src/exception.rs:50] nop
[INFO  kernel/src/exception.rs:56] jmp
...
```

However, in practice, the modified host kernel suppresses reinjection that results in the following logs:
```
...
[INFO  kernel/src/exception.rs:56] jmp
[INFO  kernel/src/exception.rs:50] nop
[INFO  kernel/src/exception.rs:56] jmp
[INFO  kernel/src/exception.rs:50] nop
[INFO  kernel/src/exception.rs:50] nop
[INFO  kernel/src/exception.rs:53] last instruction was also nop
[INFO  kernel/src/exception.rs:56] jmp
[INFO  kernel/src/exception.rs:50] nop
[INFO  kernel/src/exception.rs:56] jmp
[INFO  kernel/src/exception.rs:50] nop
[INFO  kernel/src/exception.rs:56] jmp
[INFO  kernel/src/exception.rs:50] nop
[INFO  kernel/src/exception.rs:56] jmp
[INFO  kernel/src/exception.rs:56] jmp
[INFO  kernel/src/exception.rs:59] last instruction was also jmp
[INFO  kernel/src/exception.rs:50] nop
[INFO  kernel/src/exception.rs:56] jmp
[INFO  kernel/src/exception.rs:50] nop
...
```

The suppressed events will show up in the host kernel logs:
```
...
[798678.660473] kvm_amd: exit_int_info=80000301 exit_info_1=500000004 exit_info_2=180000000 exit_code=400
[798678.678645] kvm_amd: exit_int_info=80000301 exit_info_1=500000004 exit_info_2=180000000 exit_code=400
[798678.680906] kvm_amd: exit_int_info=80000301 exit_info_1=500000004 exit_info_2=180000000 exit_code=400
[798678.683491] kvm_amd: exit_int_info=80000301 exit_info_1=500000004 exit_info_2=180000000 exit_code=400
[798678.700844] kvm_amd: exit_int_info=80000301 exit_info_1=500000004 exit_info_2=180000000 exit_code=400
[798678.712970] kvm_amd: exit_int_info=80000301 exit_info_1=500000004 exit_info_2=180000000 exit_code=400
...
```

This demonstrates that delivery of the #DB exception was suppressed.

## Impact

Suppressing #DB exceptions for single stepping probably won't have much of an inpact on most applications. Still, SEV-SNP is usually meant to keep out the host as much as possible and this bug is a clear violation of that principle.

If there are other exceptions that can be suppressed, the impact could be larger.

## Mitigation

Mitigating this isn't easy because it's a bug in the specification and not the processor itself.

The processor could store information about exceptions that need to be reinjected in the VMSA upon exit and restore it upon entering.

## Discovery

I discovered this bug after implementing Linux kernel host patches for Restricted Injection. Occasionally I would see seemingly random crashes. It turned out that Linux was trying to reinject #PF exceptions that happened at the same time as #NPF exits. The reinjections failed because Restricted Injection forbids injecting #PF exceptions. Initially I assumed that the host could simply never reinject the exception because most exceptions would be triggered again anyways, but after looking into it some more I noticed that this can lead to incorrect behaviour in the guest.

## Update - 03/16/2023 

It turns out the same bug exists for hardware breakpoints set with the Debug-Control registers. I've updated to PoC code to demonstrate this.

This code writes to writes to two memory locations in a loop:
```rust
fn debuggee() -> ! {
    loop {
        unsafe {
            (&mut BREAKPOINT_VALUE_A as *mut u64).write_volatile(1);
            (&mut BREAKPOINT_VALUE_B as *mut u64).write_volatile(1);
        }
    }
}
```

Hardware read/write breakpoints are set for these memory locations and logged whenever they trap.

In theory, the access traps should always alternate between the two locations:
```
...
[INFO  kernel/src/exception.rs:73] trap 2
[INFO  kernel/src/exception.rs:77] trap 1
[INFO  kernel/src/exception.rs:73] trap 2
[INFO  kernel/src/exception.rs:77] trap 1
[INFO  kernel/src/exception.rs:73] trap 2
[INFO  kernel/src/exception.rs:77] trap 1
[INFO  kernel/src/exception.rs:73] trap 2
[INFO  kernel/src/exception.rs:77] trap 1
[INFO  kernel/src/exception.rs:73] trap 2
[INFO  kernel/src/exception.rs:77] trap 1
[INFO  kernel/src/exception.rs:73] trap 2
[INFO  kernel/src/exception.rs:77] trap 1
...
```

In practice, the host can once again refuse delivery of the exception causing incorrect behaviour in the guest.
```
...
[INFO  kernel/src/exception.rs:77] trap 1
[INFO  kernel/src/exception.rs:73] trap 2
[INFO  kernel/src/exception.rs:73] trap 2
[INFO  kernel/src/exception.rs:86] last trap was also trap 2
[INFO  kernel/src/exception.rs:77] trap 1
[INFO  kernel/src/exception.rs:73] trap 2
[INFO  kernel/src/exception.rs:77] trap 1
[INFO  kernel/src/exception.rs:73] trap 2
[INFO  kernel/src/exception.rs:77] trap 1
[INFO  kernel/src/exception.rs:73] trap 2
[INFO  kernel/src/exception.rs:77] trap 1
[INFO  kernel/src/exception.rs:73] trap 2
[INFO  kernel/src/exception.rs:73] trap 2
[INFO  kernel/src/exception.rs:86] last trap was also trap 2
[INFO  kernel/src/exception.rs:77] trap 1
...
```