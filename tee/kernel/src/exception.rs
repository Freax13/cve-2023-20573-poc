use core::{
    cell::LazyCell,
    ptr::addr_of,
    sync::atomic::{AtomicBool, Ordering},
};

use log::info;
use x86_64::{
    registers::{
        control::{Cr4, Cr4Flags},
        debug::{
            BreakpointCondition, BreakpointSize, DebugAddressRegister, DebugAddressRegisterNumber,
            Dr0, Dr1, Dr6, Dr6Flags, Dr7, Dr7Flags,
        },
    },
    structures::idt::{InterruptDescriptorTable, InterruptStackFrame},
};

use crate::{exception::vc::vmm_communication_exception_handler, FakeSync};

mod vc;

pub fn init() {
    let mut cr4 = Cr4::read();
    cr4 |= Cr4Flags::DEBUGGING_EXTENSIONS;
    unsafe {
        Cr4::write(cr4);
    }

    // Make sure that the IDT isn't in the same page as the breakpoints.
    #[repr(C, align(4096))]
    struct AlignedIdt(InterruptDescriptorTable);

    static IDT: FakeSync<LazyCell<AlignedIdt>> = FakeSync::new(LazyCell::new(|| {
        let mut idt = InterruptDescriptorTable::new();

        idt.vmm_communication_exception
            .set_handler_fn(vmm_communication_exception_handler);
        idt.debug.set_handler_fn(debug_handler);

        AlignedIdt(idt)
    }));

    (*IDT).0.load();
}

static mut BREAKPOINT_VALUE_A: u64 = 0;
static mut BREAKPOINT_VALUE_B: u64 = 0;

pub fn run_debuggee() -> ! {
    Dr0::write(unsafe { addr_of!(BREAKPOINT_VALUE_A) } as *const _ as u64);
    Dr1::write(unsafe { addr_of!(BREAKPOINT_VALUE_B) } as *const _ as u64);

    let mut dr7 = Dr7::read();
    dr7.set_condition(
        DebugAddressRegisterNumber::Dr0,
        BreakpointCondition::DataReadsWrites,
    );
    dr7.set_condition(
        DebugAddressRegisterNumber::Dr1,
        BreakpointCondition::DataReadsWrites,
    );
    dr7.set_size(DebugAddressRegisterNumber::Dr0, BreakpointSize::Length1B);
    dr7.set_size(DebugAddressRegisterNumber::Dr1, BreakpointSize::Length1B);
    dr7.set_flags(Dr7Flags::GLOBAL_BREAKPOINT_0_ENABLE, true);
    dr7.set_flags(Dr7Flags::GLOBAL_BREAKPOINT_1_ENABLE, true);
    Dr7::write(dr7);

    debuggee();
}

static FLIPFLOP: AtomicBool = AtomicBool::new(false);

extern "x86-interrupt" fn debug_handler(_frame: InterruptStackFrame) {
    let dr6 = Dr6::read();
    if dr6.contains(Dr6Flags::TRAP0) {
        info!("trap 1");
        let prev = FLIPFLOP.swap(true, Ordering::SeqCst);
        if prev {
            info!("last trap was also trap 1");
        }
    } else if dr6.contains(Dr6Flags::TRAP1) {
        info!("trap 2");
        let prev = FLIPFLOP.swap(false, Ordering::SeqCst);
        if !prev {
            info!("last trap was also trap 2");
        }
    }
}

fn debuggee() -> ! {
    loop {
        unsafe {
            (&mut BREAKPOINT_VALUE_A as *mut u64).write_volatile(1);
            (&mut BREAKPOINT_VALUE_B as *mut u64).write_volatile(1);
        }
    }
}
